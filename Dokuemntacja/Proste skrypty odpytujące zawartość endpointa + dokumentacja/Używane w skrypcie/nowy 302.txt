https://docs.dataforseo.com/v3/serp/google/autocomplete/live/advanced/?bash


import os
import logging
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
from dotenv import load_dotenv
from dataforseo_client import configuration as dfs_config, api_client as dfs_api_provider
from dataforseo_client.api.serp_api import SerpApi
from dataforseo_client.models.serp_google_autocomplete_live_advanced_request_info import (
    SerpGoogleAutocompleteLiveAdvancedRequestInfo,
)
from datetime import datetime
from collections import Counter
import re

load_dotenv()
router = APIRouter()

# Logger
logger = logging.getLogger("dfs_autocomplete_testing")
logger.setLevel(logging.DEBUG)
handler = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s | %(levelname)s | %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)

DFS_LOGIN = os.getenv("DATAFORSEO_LOGIN")
DFS_PASSWORD = os.getenv("DATAFORSEO_PASSWORD")

# Modele danych wej≈õciowych
class AutocompleteInput(BaseModel):
    keyword: str
    location_code: Optional[int] = 2616  # Polska (Warszawa)
    language_code: Optional[str] = "pl"
    cursor_pointer: Optional[int] = None  # Pozycja kursora w keyword
    client: Optional[str] = "gws-wiz-serp"  # Typ klienta autocomplete
    include_analysis: Optional[bool] = True  # Czy do≈ÇƒÖczyƒá analizƒô BI

class AutocompleteMultiInput(BaseModel):
    keywords: List[str]
    location_code: Optional[int] = 2616
    language_code: Optional[str] = "pl"
    client: Optional[str] = "gws-wiz-serp"
    include_analysis: Optional[bool] = True

# Klasa do analizy business intelligence
class AutocompleteAnalyzer:
    
    @staticmethod
    def analyze_keyword_intent(suggestions: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Analizuje intencjƒô wyszukiwania na podstawie sugestii autocomplete
        """
        # Wzorce intencji dla jƒôzyka polskiego
        INTENT_PATTERNS = {
            "informational": [
                r"\b(jak|co|dlaczego|kiedy|gdzie|czy|jakie|jakich|czym|kim)\b",
                r"\b(znaczenie|definicja|wyja≈õnienie|opis|instrukcja)\b",
                r"\b(zasady|regu≈Çy|poradnik|tutorial|nauka)\b",
                r"\b(historia|pochodzenie|przyczyny)\b"
            ],
            "transactional": [
                r"\b(kup|kupiƒá|sklep|cena|koszt|tanio|promocja|rabat)\b",
                r"\b(ksiƒÖ≈ºka|podrƒôcznik|zestaw|materia≈Çy|produkt)\b",
                r"\b(zam√≥w|zam√≥wienie|dostawa|sprzeda≈º|online)\b",
                r"\b(allegro|empik|ceneo|sklep)\b"
            ],
            "navigational": [
                r"\b(strona|portal|serwis|oficjalna|www)\b",
                r"\.(pl|com|org|net|edu)\b",
                r"\b(logowanie|login|konto|rejestracja)\b",
                r"\b(facebook|youtube|instagram|twitter)\b"
            ],
            "local": [
                r"\b(w|warszawa|krak√≥w|gda≈Ñsk|pozna≈Ñ|wroc≈Çaw|≈Ç√≥d≈∫)\b",
                r"\b(blisko|obok|okolica|region|miasto)\b",
                r"\b(adres|telefon|godziny|otwarcie)\b"
            ],
            "educational": [
                r"\b(klasa|szko≈Ça|uczni√≥w|nauczyciel|edukacja)\b",
                r"\b(ƒáwiczenia|zadania|test|sprawdzian|egzamin)\b",
                r"\b(nauka|learning|kurs|lekcja)\b"
            ]
        }
        
        intent_counts = {intent: 0 for intent in INTENT_PATTERNS.keys()}
        categorized_suggestions = {intent: [] for intent in INTENT_PATTERNS.keys()}
        
        for suggestion in suggestions:
            text = suggestion.get("suggestion", "").lower()
            
            for intent, patterns in INTENT_PATTERNS.items():
                for pattern in patterns:
                    if re.search(pattern, text, re.IGNORECASE):
                        intent_counts[intent] += 1
                        categorized_suggestions[intent].append(suggestion.get("suggestion"))
                        break
        
        total = sum(intent_counts.values())
        intent_distribution = {}
        
        if total > 0:
            intent_distribution = {
                intent: round((count / total) * 100, 1) 
                for intent, count in intent_counts.items()
                if count > 0
            }
        
        return {
            "intent_distribution": intent_distribution,
            "categorized_suggestions": categorized_suggestions,
            "total_analyzed": len(suggestions),
            "primary_intent": max(intent_distribution.items(), key=lambda x: x[1])[0] if intent_distribution else "unknown"
        }

    @staticmethod
    def extract_trending_modifiers(suggestions: List[Dict[str, Any]], base_keyword: str) -> Dict[str, Any]:
        """
        WyciƒÖga trending modyfikatory i wzorce z sugestii
        """
        all_suggestions = [s.get("suggestion", "") for s in suggestions]
        all_text = " ".join(all_suggestions).lower()
        
        # Wyodrƒôbnij s≈Çowa, usu≈Ñ base keyword
        words = re.findall(r'\b\w+\b', all_text)
        base_words = set(base_keyword.lower().split())
        filtered_words = [w for w in words if w not in base_words and len(w) > 2]
        
        # Policz czƒôstotliwo≈õƒá
        word_freq = Counter(filtered_words)
        
        # Kategorie modyfikator√≥w
        MODIFIER_CATEGORIES = {
            "format": ["online", "pdf", "interaktywne", "audio", "wideo", "app", "aplikacja"],
            "target": ["dzieci", "doros≈Çych", "klasa", "szko≈Ça", "uczni√≥w", "nauczyciel"],
            "difficulty": ["≈Çatwe", "trudne", "kr√≥tkie", "d≈Çugie", "podstawowe", "zaawansowane"],
            "topic": ["ortografia", "gramatyka", "interpunkcja", "pisownia", "jƒôzyk"],
            "commercial": ["cena", "sklep", "ksiƒÖ≈ºka", "materia≈Çy", "zestaw", "tanio"],
            "time": ["nowe", "2024", "2025", "aktualne", "najnowsze"]
        }
        
        detected_modifiers = {}
        for category, keywords in MODIFIER_CATEGORIES.items():
            detected = [(word, word_freq[word]) for word in word_freq.keys() if word in keywords]
            if detected:
                detected_modifiers[category] = sorted(detected, key=lambda x: x[1], reverse=True)
        
        # Znajd≈∫ highlighted terms (je≈õli dostƒôpne)
        highlighted_terms = []
        for suggestion in suggestions:
            if suggestion.get("highlighted"):
                highlighted_terms.extend(suggestion["highlighted"])
        
        return {
            "top_modifiers": dict(word_freq.most_common(15)),
            "categorized_modifiers": detected_modifiers,
            "highlighted_terms": list(set(highlighted_terms)),
            "long_tail_opportunities": [s for s in all_suggestions if len(s.split()) >= 4],
            "question_patterns": [s for s in all_suggestions if any(q in s.lower() for q in ["jak", "co", "dlaczego", "kiedy", "gdzie", "czy"])]
        }

    @staticmethod
    def identify_content_opportunities(suggestions: List[Dict[str, Any]], base_keyword: str) -> List[Dict[str, Any]]:
        """
        Identyfikuje okazje content marketingowe na podstawie sugestii
        """
        opportunities = []
        
        # Analiza d≈Çugich fraz (long-tail keywords)
        for suggestion in suggestions:
            text = suggestion.get("suggestion", "")
            rank = suggestion.get("rank_absolute", 999)
            
            if len(text.split()) >= 3:
                difficulty = "Easy" if rank > 7 else "Medium" if rank > 4 else "Hard"
                
                opportunity = {
                    "keyword": text,
                    "rank": rank,
                    "opportunity_type": "long_tail",
                    "difficulty": difficulty,
                    "reason": f"D≈Çuga fraza ({len(text.split())} s≈Ç√≥w) - potencjalnie mniejsza konkurencja",
                    "word_count": len(text.split())
                }
                opportunities.append(opportunity)
        
        # Szukaj unique angles/modifiers
        all_suggestions = [s.get("suggestion", "") for s in suggestions]
        for suggestion_data in suggestions:
            text = suggestion_data.get("suggestion", "")
            words = text.lower().split()
            
            # Znajd≈∫ unikalne modyfikatory
            unique_words = []
            for word in words:
                if len(word) > 3 and sum(1 for s in all_suggestions if word in s.lower()) == 1:
                    unique_words.append(word)
            
            if unique_words:
                opportunity = {
                    "keyword": text,
                    "rank": suggestion_data.get("rank_absolute", 999),
                    "opportunity_type": "unique_angle", 
                    "unique_modifiers": unique_words,
                    "reason": f"Zawiera unikalne modyfikatory: {', '.join(unique_words)}"
                }
                opportunities.append(opportunity)
        
        # Analiza intent gaps
        educational_terms = ["nauka", "jak", "tutorial", "poradnik", "instrukcja"]
        commercial_terms = ["cena", "kup", "sklep", "tanio", "promocja"]
        
        has_educational = any(any(term in s.get("suggestion", "").lower() for term in educational_terms) for s in suggestions)
        has_commercial = any(any(term in s.get("suggestion", "").lower() for term in commercial_terms) for s in suggestions)
        
        if not has_educational:
            opportunities.append({
                "keyword": f"{base_keyword} nauka",
                "opportunity_type": "intent_gap",
                "reason": "Brak sugestii edukacyjnych - mo≈ºliwo≈õƒá stworzenia content'u 'how-to'",
                "suggested_content": ["Tutorial", "Poradnik krok po kroku", "Nauka dla poczƒÖtkujƒÖcych"]
            })
        
        if not has_commercial:
            opportunities.append({
                "keyword": f"{base_keyword} cena",
                "opportunity_type": "intent_gap", 
                "reason": "Brak sugestii komercyjnych - mo≈ºliwo≈õƒá monetyzacji",
                "suggested_content": ["Por√≥wnanie cen", "Gdzie kupiƒá najtaniej", "Recenzje produkt√≥w"]
            })
        
        return sorted(opportunities, key=lambda x: x.get("rank", 999))[:10]  # Top 10

    @staticmethod
    def generate_comprehensive_analysis(suggestions: List[Dict[str, Any]], base_keyword: str) -> Dict[str, Any]:
        """
        Generuje kompletnƒÖ analizƒô business intelligence
        """
        intent_analysis = AutocompleteAnalyzer.analyze_keyword_intent(suggestions)
        trending_analysis = AutocompleteAnalyzer.extract_trending_modifiers(suggestions, base_keyword)
        opportunities = AutocompleteAnalyzer.identify_content_opportunities(suggestions, base_keyword)
        
        # Dodatkowe metryki
        avg_length = sum(len(s.get("suggestion", "").split()) for s in suggestions) / len(suggestions) if suggestions else 0
        
        with_thumbnails = sum(1 for s in suggestions if s.get("thumbnail_url"))
        thumbnail_percentage = (with_thumbnails / len(suggestions) * 100) if suggestions else 0
        
        return {
            "intent_analysis": intent_analysis,
            "trending_modifiers": trending_analysis,
            "content_opportunities": opportunities,
            "metrics": {
                "total_suggestions": len(suggestions),
                "average_suggestion_length": round(avg_length, 1),
                "suggestions_with_thumbnails": with_thumbnails,
                "thumbnail_percentage": round(thumbnail_percentage, 1),
                "primary_intent": intent_analysis.get("primary_intent", "unknown"),
                "top_modifier": list(trending_analysis["top_modifiers"].keys())[0] if trending_analysis["top_modifiers"] else None,
                "opportunity_count": len(opportunities)
            },
            "summary": {
                "recommendation": AutocompleteAnalyzer._generate_recommendation(intent_analysis, trending_analysis, opportunities),
                "key_insights": AutocompleteAnalyzer._generate_key_insights(intent_analysis, trending_analysis, opportunities)
            }
        }
    
    @staticmethod
    def _generate_recommendation(intent_analysis: Dict, trending_analysis: Dict, opportunities: List) -> str:
        """
        Generuje rekomendacjƒô biznesowƒÖ na podstawie analizy
        """
        primary_intent = intent_analysis.get("primary_intent", "unknown")
        top_modifiers = list(trending_analysis["top_modifiers"].keys())[:3]
        
        if primary_intent == "educational":
            return f"Fokus na content edukacyjny. Kluczowe modyfikatory: {', '.join(top_modifiers)}. Rozwa≈º stworzenie tutoriali i poradnik√≥w."
        elif primary_intent == "transactional":
            return f"Silny intent komercyjny. Priorytet: landing pages produktowe i por√≥wnania cen. Modyfikatory: {', '.join(top_modifiers)}."
        elif primary_intent == "informational":
            return f"Zapotrzebowanie na tre≈õci informacyjne. Stw√≥rz FAQ, definicje i wyja≈õnienia. Focus: {', '.join(top_modifiers)}."
        else:
            return f"Mieszane intencje. Strategia: diversyfikacja content'u. G≈Ç√≥wne kierunki: {', '.join(top_modifiers)}."
    
    @staticmethod 
    def _generate_key_insights(intent_analysis: Dict, trending_analysis: Dict, opportunities: List) -> List[str]:
        """
        Generuje kluczowe insights
        """
        insights = []
        
        # Intent insights
        primary_intent = intent_analysis.get("primary_intent")
        if primary_intent:
            percentage = intent_analysis["intent_distribution"].get(primary_intent, 0)
            insights.append(f"Dominuje intent {primary_intent} ({percentage}% sugestii)")
        
        # Modifier insights  
        top_modifiers = list(trending_analysis["top_modifiers"].items())[:2]
        if top_modifiers:
            insights.append(f"Najczƒôstsze modyfikatory: {', '.join([f'{mod} ({count}x)' for mod, count in top_modifiers])}")
        
        # Opportunity insights
        easy_opportunities = [opp for opp in opportunities if opp.get("difficulty") == "Easy"]
        if easy_opportunities:
            insights.append(f"Znaleziono {len(easy_opportunities)} ≈Çatwych okazji long-tail")
        
        # Format insights
        format_mods = trending_analysis["categorized_modifiers"].get("format", [])
        if format_mods:
            insights.append(f"Preferowane formaty: {', '.join([mod[0] for mod in format_mods[:2]])}")
        
        return insights

# G≈Ç√≥wne endpointy
@router.post("/autocomplete/google/live/advanced")
async def get_google_autocomplete_live_advanced(data: AutocompleteInput):
    """
    Pobiera dane z Live Google Autocomplete Advanced endpoint.
    Zwraca sugestie autocomplete z opcjonalnƒÖ analizƒÖ business intelligence.
    """
    if not DFS_LOGIN or not DFS_PASSWORD:
        logger.error("‚ùå Brak danych logowania do API")
        raise HTTPException(status_code=500, detail="Brak danych logowania do API DataForSEO.")
    
    logger.info(f"üîç Pobieranie autocomplete dla: '{data.keyword}'")
    logger.info(f"üìç Lokalizacja: {data.location_code}, Jƒôzyk: {data.language_code}")
    logger.info(f"üñ•Ô∏è Klient: {data.client}")
    if data.cursor_pointer is not None:
        logger.info(f"üëÜ Pozycja kursora: {data.cursor_pointer}")
    
    config = dfs_config.Configuration(username=DFS_LOGIN, password=DFS_PASSWORD)
    
    # Przygotowanie requestu
    request_params = {
        "keyword": data.keyword,
        "location_code": data.location_code,
        "language_code": data.language_code,
        "client": data.client
    }
    
    if data.cursor_pointer is not None:
        request_params["cursor_pointer"] = data.cursor_pointer
    
    request_data = [SerpGoogleAutocompleteLiveAdvancedRequestInfo(**request_params)]
    
    try:
        with dfs_api_provider.ApiClient(config) as api_client:
            api_instance = SerpApi(api_client)
            logger.debug("‚û°Ô∏è Wysy≈Çanie ≈ºƒÖdania do DataForSEO Autocomplete API...")
            
            # Wywo≈Çanie endpointu
            api_response = api_instance.google_autocomplete_live_advanced(request_data)
            
            if not api_response.tasks:
                logger.warning("‚ö†Ô∏è Brak zada≈Ñ w odpowiedzi API.")
                raise HTTPException(status_code=404, detail="Brak danych w odpowiedzi API.")
            
            task = api_response.tasks[0]
            
            if task.status_code != 20000:
                logger.error(f"‚ùå B≈ÇƒÖd zadania: {task.status_code} - {task.status_message}")
                raise HTTPException(
                    status_code=400, 
                    detail=f"B≈ÇƒÖd zadania DataForSEO: {task.status_message}"
                )
            
            if not task.result:
                logger.warning("‚ö†Ô∏è Brak wynik√≥w autocomplete dla podanego s≈Çowa kluczowego.")
                raise HTTPException(
                    status_code=404, 
                    detail="Brak sugestii autocomplete dla podanego s≈Çowa kluczowego."
                )
            
            result = task.result[0]
            
            # Logowanie podstawowych informacji
            logger.info(f"‚úÖ Pobrano dane autocomplete dla '{result.keyword}'")
            logger.info(f"üìä Liczba sugestii: {result.items_count}")
            logger.info(f"üîó URL sprawdzajƒÖcy: {result.check_url}")
            
            # Konwersja wynik√≥w do dict
            result_dict = result.to_dict()
            
            # Przygotowanie odpowiedzi
            response_data = {
                "task_info": {
                    "id": task.id,
                    "status_code": task.status_code,
                    "status_message": task.status_message,
                    "cost": task.cost,
                    "execution_time": task.time
                },
                "autocomplete_data": result_dict
            }
            
            # Dodaj analizƒô BI je≈õli requested
            if data.include_analysis and result.items:
                logger.info("üß† Generowanie analizy business intelligence...")
                
                # Konwertuj items do listy dict dla analizy
                suggestions = []
                for item in result.items:
                    suggestions.append(item.to_dict())
                
                analysis = AutocompleteAnalyzer.generate_comprehensive_analysis(suggestions, data.keyword)
                response_data["business_intelligence"] = analysis
                
                logger.info(f"üìà Analiza zako≈Ñczona - {analysis['metrics']['total_suggestions']} sugestii przeanalizowanych")
            
            # Dodaj metadata
            response_data["metadata"] = {
                "timestamp": datetime.now().isoformat(),
                "analysis_included": data.include_analysis,
                "total_cost": task.cost
            }
            
            return response_data
    
    except Exception as e:
        logger.exception("‚ùå B≈ÇƒÖd podczas pobierania danych z DataForSEO Autocomplete API")
        raise HTTPException(
            status_code=500, 
            detail=f"B≈ÇƒÖd serwera podczas pobierania danych autocomplete:\n{str(e)}"
        )

@router.post("/autocomplete/google/multi")
async def get_multiple_autocomplete(data: AutocompleteMultiInput):
    """
    Pobiera dane autocomplete dla wielu keywords jednocze≈õnie.
    Przydatne do bulk keyword research.
    """
    if len(data.keywords) > 10:
        raise HTTPException(status_code=400, detail="Maksymalnie 10 keywords na raz.")
    
    logger.info(f"üîç Pobieranie autocomplete dla {len(data.keywords)} keywords")
    
    results = []
    total_cost = 0.0
    
    for keyword in data.keywords:
        try:
            # Wywo≈Çaj g≈Ç√≥wny endpoint dla ka≈ºdego keyword
            single_request = AutocompleteInput(
                keyword=keyword,
                location_code=data.location_code,
                language_code=data.language_code,
                client=data.client,
                include_analysis=data.include_analysis
            )
            
            result = await get_google_autocomplete_live_advanced(single_request)
            results.append({
                "keyword": keyword,
                "success": True,
                "data": result
            })
            
            total_cost += result["task_info"]["cost"]
            
        except Exception as e:
            logger.error(f"‚ùå B≈ÇƒÖd dla keyword '{keyword}': {str(e)}")
            results.append({
                "keyword": keyword,
                "success": False,
                "error": str(e)
            })
    
    successful_results = [r for r in results if r["success"]]
    
    return {
        "summary": {
            "total_keywords": len(data.keywords),
            "successful": len(successful_results),
            "failed": len(data.keywords) - len(successful_results),
            "total_cost": total_cost
        },
        "results": results,
        "metadata": {
            "timestamp": datetime.now().isoformat(),
            "analysis_included": data.include_analysis
        }
    }

@router.post("/autocomplete/google/filtered")
async def get_filtered_autocomplete(data: AutocompleteInput, min_rank: Optional[int] = None, max_rank: Optional[int] = None, contains: Optional[str] = None):
    """
    Pobiera dane autocomplete z filtrowaniem wynik√≥w.
    
    Parametry filtrowania:
    - min_rank: Minimalna pozycja w rankingu (np. 1)
    - max_rank: Maksymalna pozycja w rankingu (np. 5) 
    - contains: Tekst kt√≥ry musi zawieraƒá sugestia
    """
    # Pobierz pe≈Çne dane
    full_response = await get_google_autocomplete_live_advanced(data)
    
    # Zastosuj filtry
    if "autocomplete_data" in full_response and "items" in full_response["autocomplete_data"]:
        items = full_response["autocomplete_data"]["items"]
        filtered_items = []
        
        for item in items:
            # Filtr po rank
            rank = item.get("rank_absolute", 0)
            if min_rank and rank < min_rank:
                continue
            if max_rank and rank > max_rank:
                continue
                
            # Filtr po zawarto≈õci
            if contains and contains.lower() not in item.get("suggestion", "").lower():
                continue
                
            filtered_items.append(item)
        
        # Aktualizuj dane
        full_response["autocomplete_data"]["items"] = filtered_items
        full_response["autocomplete_data"]["items_count"] = len(filtered_items)
        
        # Aktualizuj analizƒô je≈õli by≈Ça included
        if data.include_analysis and "business_intelligence" in full_response:
            analysis = AutocompleteAnalyzer.generate_comprehensive_analysis(filtered_items, data.keyword)
            full_response["business_intelligence"] = analysis
        
        logger.info(f"üîç Przefiltrowano do {len(filtered_items)} sugestii")
        
        # Dodaj info o filtrach
        full_response["filter_info"] = {
            "applied_filters": {
                "min_rank": min_rank,
                "max_rank": max_rank, 
                "contains": contains
            },
            "original_count": len(items),
            "filtered_count": len(filtered_items)
        }
    
    return full_response

@router.get("/autocomplete/google/quick/{keyword}")
async def get_quick_autocomplete(
    keyword: str,
    location_code: int = 2616,
    language_code: str = "pl",
    limit: int = 5
):
    """
    Szybkie pobranie top autocomplete suggestions bez pe≈Çnej analizy.
    Przydatne do szybkich lookup'√≥w.
    """
    try:
        request = AutocompleteInput(
            keyword=keyword,
            location_code=location_code,
            language_code=language_code,
            include_analysis=False
        )
        
        result = await get_google_autocomplete_live_advanced(request)
        
        # WyciƒÖgnij tylko sugestie
        suggestions = []
        if "autocomplete_data" in result and "items" in result["autocomplete_data"]:
            items = result["autocomplete_data"]["items"][:limit]
            suggestions = [item.get("suggestion", "") for item in items]
        
        return {
            "keyword": keyword,
            "suggestions": suggestions,
            "count": len(suggestions),
            "cost": result["task_info"]["cost"]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd: {str(e)}")

# Endpoint informacyjny
@router.get("/info/autocomplete-clients")
async def get_autocomplete_clients():
    """
    Zwraca listƒô dostƒôpnych klient√≥w autocomplete i ich zastosowania.
    """
    clients_info = {
        "chrome": {
            "description": "Google Search w przeglƒÖdarce Chrome",
            "use_case": "Standardowe wyszukiwanie desktop"
        },
        "chrome-omni": {
            "description": "Pasek adresu w Chrome", 
            "use_case": "Wyszukiwanie z paska adresu",
            "features": ["relevance_score", "suggestion_type"]
        },
        "gws-wiz": {
            "description": "Strona g≈Ç√≥wna Google Search",
            "use_case": "Homepage search experience",
            "features": ["thumbnail_images"]
        },
        "gws-wiz-serp": {
            "description": "Strona wynik√≥w Google Search (SERP)",
            "use_case": "Search refinement na SERP",
            "features": ["thumbnail_images", "highlighted_terms"]
        },
        "safari": {
            "description": "Google Search w przeglƒÖdarce Safari",
            "use_case": "Safari browser experience"
        },
        "firefox": {
            "description": "Google Search w przeglƒÖdarce Firefox", 
            "use_case": "Firefox browser experience"
        },
        "gws-wiz-local": {
            "description": "Google Local Search",
            "use_case": "Local/geo-targeted searches"
        },
        "img": {
            "description": "Google Images search",
            "use_case": "Image search autocomplete"
        },
        "products-cc": {
            "description": "Google Shopping search",
            "use_case": "E-commerce/product searches"
        }
    }
    
    return {
        "available_clients": clients_info,
        "recommended": {
            "general_research": "gws-wiz-serp",
            "local_seo": "gws-wiz-local", 
            "ecommerce": "products-cc",
            "image_search": "img"
        }
    }

# Endpoint sprawdzajƒÖcy dostƒôpne lokalizacje (z oryginalnego kodu)
@router.get("/info/available-locations")
async def get_available_locations():
    """
    Zwraca listƒô dostƒôpnych lokalizacji dla Google Autocomplete.
    """
    if not DFS_LOGIN or not DFS_PASSWORD:
        raise HTTPException(status_code=500, detail="Brak danych logowania do API DataForSEO.")
    
    config = dfs_config.Configuration(username=DFS_LOGIN, password=DFS_PASSWORD)
    
    try:
        with dfs_api_provider.ApiClient(config) as api_client:
            api_instance = SerpApi(api_client)
            api_response = api_instance.google_autocomplete_locations()
            
            return {
                "locations_count": len(api_response.tasks[0].result),
                "locations": api_response.tasks[0].result
            }
    except Exception as e:
        logger.exception("‚ùå B≈ÇƒÖd podczas pobierania listy lokalizacji")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd serwera:\n{str(e)}")

@router.get("/info/available-languages") 
async def get_available_languages():
    """
    Zwraca listƒô dostƒôpnych jƒôzyk√≥w dla Google Autocomplete.
    """
    if not DFS_LOGIN or not DFS_PASSWORD:
        raise HTTPException(status_code=500, detail="Brak danych logowania do API DataForSEO.")
    
    config = dfs_config.Configuration(username=DFS_LOGIN, password=DFS_PASSWORD)
    
    try:
        with dfs_api_provider.ApiClient(config) as api_client:
            api_instance = SerpApi(api_client)
            api_response = api_instance.google_languages()
            
            return {
                "languages_count": len(api_response.tasks[0].result),
                "languages": api_response.tasks[0].result
            }
    except Exception as e:
        logger.exception("‚ùå B≈ÇƒÖd podczas pobierania listy jƒôzyk√≥w")
        raise HTTPException(status_code=500, detail=f"B≈ÇƒÖd serwera:\n{str(e)}")
		
		
		
		
		



{
  "task_info": {
    "id": "06022226-1002-0139-0000-8946700a456c",
    "status_code": 20000,
    "status_message": "Ok.",
    "cost": 0.002,
    "execution_time": "1.2249 sec."
  },
  "autocomplete_data": {
    "keyword": "dyktanda",
    "type": "autocomplete",
    "se_domain": "google.pl",
    "location_code": 2616,
    "language_code": "pl",
    "check_url": "https://google.pl/search?q=dyktanda&hl=pl&gl=PL&uule=w+CAIQIFISCbsLZKRkmQBHEepVzEnKc3UJ",
    "datetime": "2025-06-02 19:26:57 +00:00",
    "item_types": [
      "autocomplete"
    ],
    "se_results_count": 0,
    "items_count": 10,
    "items": [
      {
        "type": "autocomplete",
        "rank_group": 1,
        "rank_absolute": 1,
        "suggestion": "tekst do dyktanda klasa 3",
        "search_query_url": "https://www.google.pl/search?q=tekst+do+dyktanda+klasa+3",
        "highlighted": [
          "tekst do",
          "klasa 3"
        ],
        "relevance": null,
        "suggestion_type": null,
        "thumbnail_url": null
      },
      {
        "type": "autocomplete",
        "rank_group": 2,
        "rank_absolute": 2,
        "suggestion": "dyktanda online",
        "search_query_url": "https://www.google.pl/search?q=dyktanda+online",
        "highlighted": [
          "online"
        ],
        "relevance": null,
        "suggestion_type": null,
        "thumbnail_url": null
      },
      {
        "type": "autocomplete",
        "rank_group": 3,
        "rank_absolute": 3,
        "suggestion": "kr√≥tkie dyktanda klasa 2",
        "search_query_url": "https://www.google.pl/search?q=kr%C3%B3tkie+dyktanda+klasa+2",
        "highlighted": [
          "kr√≥tkie",
          "klasa 2"
        ],
        "relevance": null,
        "suggestion_type": null,
        "thumbnail_url": null
      },
      {
        "type": "autocomplete",
        "rank_group": 4,
        "rank_absolute": 4,
        "suggestion": "tekst do dyktanda klasa 4",
        "search_query_url": "https://www.google.pl/search?q=tekst+do+dyktanda+klasa+4",
        "highlighted": [
          "tekst do",
          "klasa 4"
        ],
        "relevance": null,
        "suggestion_type": null,
        "thumbnail_url": null
      },
      {
        "type": "autocomplete",
        "rank_group": 5,
        "rank_absolute": 5,
        "suggestion": "kr√≥tkie dyktanda klasa 1",
        "search_query_url": "https://www.google.pl/search?q=kr%C3%B3tkie+dyktanda+klasa+1",
        "highlighted": [
          "kr√≥tkie",
          "klasa 1"
        ],
        "relevance": null,
        "suggestion_type": null,
        "thumbnail_url": null
      },
      {
        "type": "autocomplete",
        "rank_group": 6,
        "rank_absolute": 6,
        "suggestion": "kr√≥tkie dyktanda klasa 3",
        "search_query_url": "https://www.google.pl/search?q=kr%C3%B3tkie+dyktanda+klasa+3",
        "highlighted": [
          "kr√≥tkie",
          "klasa 3"
        ],
        "relevance": null,
        "suggestion_type": null,
        "thumbnail_url": null
      },
      {
        "type": "autocomplete",
        "rank_group": 7,
        "rank_absolute": 7,
        "suggestion": "darmowe dyktanda do druku",
        "search_query_url": "https://www.google.pl/search?q=darmowe+dyktanda+do+druku",
        "highlighted": [
          "darmowe",
          "do druku"
        ],
        "relevance": null,
        "suggestion_type": null,
        "thumbnail_url": null
      },
      {
        "type": "autocomplete",
        "rank_group": 8,
        "rank_absolute": 8,
        "suggestion": "dyktanda online klasa 3",
        "search_query_url": "https://www.google.pl/search?q=dyktanda+online+klasa+3",
        "highlighted": [
          "online klasa 3"
        ],
        "relevance": null,
        "suggestion_type": null,
        "thumbnail_url": null
      },
      {
        "type": "autocomplete",
        "rank_group": 9,
        "rank_absolute": 9,
        "suggestion": "dyktanda online klasa 2",
        "search_query_url": "https://www.google.pl/search?q=dyktanda+online+klasa+2",
        "highlighted": [
          "online klasa 2"
        ],
        "relevance": null,
        "suggestion_type": null,
        "thumbnail_url": null
      },
      {
        "type": "autocomplete",
        "rank_group": 10,
        "rank_absolute": 10,
        "suggestion": "dyktanda",
        "search_query_url": "https://www.google.pl/search?q=dyktanda",
        "relevance": null,
        "suggestion_type": null,
        "thumbnail_url": null,
        "highlighted": null
      }
    ]
  },
  "business_intelligence": {
    "intent_analysis": {
      "intent_distribution": {
        "transactional": 30,
        "educational": 70
      },
      "categorized_suggestions": {
        "informational": [],
        "transactional": [
          "dyktanda online",
          "dyktanda online klasa 3",
          "dyktanda online klasa 2"
        ],
        "navigational": [],
        "local": [],
        "educational": [
          "tekst do dyktanda klasa 3",
          "kr√≥tkie dyktanda klasa 2",
          "tekst do dyktanda klasa 4",
          "kr√≥tkie dyktanda klasa 1",
          "kr√≥tkie dyktanda klasa 3",
          "dyktanda online klasa 3",
          "dyktanda online klasa 2"
        ]
      },
      "total_analyzed": 10,
      "primary_intent": "educational"
    },
    "trending_modifiers": {
      "top_modifiers": {
        "klasa": 7,
        "online": 3,
        "kr√≥tkie": 3,
        "tekst": 2,
        "darmowe": 1,
        "druku": 1
      },
      "categorized_modifiers": {
        "format": [
          [
            "online",
            3
          ]
        ],
        "target": [
          [
            "klasa",
            7
          ]
        ],
        "difficulty": [
          [
            "kr√≥tkie",
            3
          ]
        ]
      },
      "highlighted_terms": [
        "kr√≥tkie",
        "online",
        "klasa 2",
        "online klasa 3",
        "klasa 3",
        "tekst do",
        "do druku",
        "darmowe",
        "klasa 1",
        "online klasa 2",
        "klasa 4"
      ],
      "long_tail_opportunities": [
        "tekst do dyktanda klasa 3",
        "kr√≥tkie dyktanda klasa 2",
        "tekst do dyktanda klasa 4",
        "kr√≥tkie dyktanda klasa 1",
        "kr√≥tkie dyktanda klasa 3",
        "darmowe dyktanda do druku",
        "dyktanda online klasa 3",
        "dyktanda online klasa 2"
      ],
      "question_patterns": []
    },
    "content_opportunities": [
      {
        "keyword": "tekst do dyktanda klasa 3",
        "rank": 1,
        "opportunity_type": "long_tail",
        "difficulty": "Hard",
        "reason": "D≈Çuga fraza (5 s≈Ç√≥w) - potencjalnie mniejsza konkurencja",
        "word_count": 5
      },
      {
        "keyword": "kr√≥tkie dyktanda klasa 2",
        "rank": 3,
        "opportunity_type": "long_tail",
        "difficulty": "Hard",
        "reason": "D≈Çuga fraza (4 s≈Ç√≥w) - potencjalnie mniejsza konkurencja",
        "word_count": 4
      },
      {
        "keyword": "tekst do dyktanda klasa 4",
        "rank": 4,
        "opportunity_type": "long_tail",
        "difficulty": "Hard",
        "reason": "D≈Çuga fraza (5 s≈Ç√≥w) - potencjalnie mniejsza konkurencja",
        "word_count": 5
      },
      {
        "keyword": "kr√≥tkie dyktanda klasa 1",
        "rank": 5,
        "opportunity_type": "long_tail",
        "difficulty": "Medium",
        "reason": "D≈Çuga fraza (4 s≈Ç√≥w) - potencjalnie mniejsza konkurencja",
        "word_count": 4
      },
      {
        "keyword": "kr√≥tkie dyktanda klasa 3",
        "rank": 6,
        "opportunity_type": "long_tail",
        "difficulty": "Medium",
        "reason": "D≈Çuga fraza (4 s≈Ç√≥w) - potencjalnie mniejsza konkurencja",
        "word_count": 4
      },
      {
        "keyword": "darmowe dyktanda do druku",
        "rank": 7,
        "opportunity_type": "long_tail",
        "difficulty": "Medium",
        "reason": "D≈Çuga fraza (4 s≈Ç√≥w) - potencjalnie mniejsza konkurencja",
        "word_count": 4
      },
      {
        "keyword": "darmowe dyktanda do druku",
        "rank": 7,
        "opportunity_type": "unique_angle",
        "unique_modifiers": [
          "darmowe",
          "druku"
        ],
        "reason": "Zawiera unikalne modyfikatory: darmowe, druku"
      },
      {
        "keyword": "dyktanda online klasa 3",
        "rank": 8,
        "opportunity_type": "long_tail",
        "difficulty": "Easy",
        "reason": "D≈Çuga fraza (4 s≈Ç√≥w) - potencjalnie mniejsza konkurencja",
        "word_count": 4
      },
      {
        "keyword": "dyktanda online klasa 2",
        "rank": 9,
        "opportunity_type": "long_tail",
        "difficulty": "Easy",
        "reason": "D≈Çuga fraza (4 s≈Ç√≥w) - potencjalnie mniejsza konkurencja",
        "word_count": 4
      },
      {
        "keyword": "dyktanda nauka",
        "opportunity_type": "intent_gap",
        "reason": "Brak sugestii edukacyjnych - mo≈ºliwo≈õƒá stworzenia content'u 'how-to'",
        "suggested_content": [
          "Tutorial",
          "Poradnik krok po kroku",
          "Nauka dla poczƒÖtkujƒÖcych"
        ]
      }
    ],
    "metrics": {
      "total_suggestions": 10,
      "average_suggestion_length": 3.7,
      "suggestions_with_thumbnails": 0,
      "thumbnail_percentage": 0,
      "primary_intent": "educational",
      "top_modifier": "klasa",
      "opportunity_count": 10
    },
    "summary": {
      "recommendation": "Fokus na content edukacyjny. Kluczowe modyfikatory: klasa, online, kr√≥tkie. Rozwa≈º stworzenie tutoriali i poradnik√≥w.",
      "key_insights": [
        "Dominuje intent educational (70.0% sugestii)",
        "Najczƒôstsze modyfikatory: klasa (7x), online (3x)",
        "Znaleziono 2 ≈Çatwych okazji long-tail",
        "Preferowane formaty: online"
      ]
    }
  },
  "metadata": {
    "timestamp": "2025-06-02T21:26:57.204906",
    "analysis_included": true,
    "total_cost": 0.002
  }
}